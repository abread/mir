// Code generated by Mir codegen. DO NOT EDIT.

package directorpbtypes

import (
	"time"

	mirreflect "github.com/filecoin-project/mir/codegen/mirreflect"
	types "github.com/filecoin-project/mir/pkg/pb/aleapb/common/types"
	directorpb "github.com/filecoin-project/mir/pkg/pb/aleapb/directorpb"
	reflectutil "github.com/filecoin-project/mir/pkg/util/reflectutil"
)

type Event struct {
	Type Event_Type
}

type Event_Type interface {
	mirreflect.GeneratedType
	isEvent_Type()
	Pb() directorpb.Event_Type
}

type Event_TypeWrapper[T any] interface {
	Event_Type
	Unwrap() *T
}

func Event_TypeFromPb(pb directorpb.Event_Type) Event_Type {
	if pb == nil {
		return nil
	}
	switch pb := pb.(type) {
	case *directorpb.Event_Heartbeat:
		return &Event_Heartbeat{Heartbeat: HeartbeatFromPb(pb.Heartbeat)}
	case *directorpb.Event_FillGap:
		return &Event_FillGap{FillGap: DoFillGapFromPb(pb.FillGap)}
	case *directorpb.Event_Stats:
		return &Event_Stats{Stats: StatsFromPb(pb.Stats)}
	}
	return nil
}

type Event_Heartbeat struct {
	Heartbeat *Heartbeat
}

func (*Event_Heartbeat) isEvent_Type() {}

func (w *Event_Heartbeat) Unwrap() *Heartbeat {
	return w.Heartbeat
}

func (w *Event_Heartbeat) Pb() directorpb.Event_Type {
	if w == nil {
		return nil
	}
	if w.Heartbeat == nil {
		return &directorpb.Event_Heartbeat{}
	}
	return &directorpb.Event_Heartbeat{Heartbeat: (w.Heartbeat).Pb()}
}

func (*Event_Heartbeat) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*directorpb.Event_Heartbeat]()}
}

type Event_FillGap struct {
	FillGap *DoFillGap
}

func (*Event_FillGap) isEvent_Type() {}

func (w *Event_FillGap) Unwrap() *DoFillGap {
	return w.FillGap
}

func (w *Event_FillGap) Pb() directorpb.Event_Type {
	if w == nil {
		return nil
	}
	if w.FillGap == nil {
		return &directorpb.Event_FillGap{}
	}
	return &directorpb.Event_FillGap{FillGap: (w.FillGap).Pb()}
}

func (*Event_FillGap) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*directorpb.Event_FillGap]()}
}

type Event_Stats struct {
	Stats *Stats
}

func (*Event_Stats) isEvent_Type() {}

func (w *Event_Stats) Unwrap() *Stats {
	return w.Stats
}

func (w *Event_Stats) Pb() directorpb.Event_Type {
	if w == nil {
		return nil
	}
	if w.Stats == nil {
		return &directorpb.Event_Stats{}
	}
	return &directorpb.Event_Stats{Stats: (w.Stats).Pb()}
}

func (*Event_Stats) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*directorpb.Event_Stats]()}
}

func EventFromPb(pb *directorpb.Event) *Event {
	if pb == nil {
		return nil
	}
	return &Event{
		Type: Event_TypeFromPb(pb.Type),
	}
}

func (m *Event) Pb() *directorpb.Event {
	if m == nil {
		return nil
	}
	pbMessage := &directorpb.Event{}
	{
		if m.Type != nil {
			pbMessage.Type = (m.Type).Pb()
		}
	}

	return pbMessage
}

func (*Event) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*directorpb.Event]()}
}

type Heartbeat struct{}

func HeartbeatFromPb(pb *directorpb.Heartbeat) *Heartbeat {
	if pb == nil {
		return nil
	}
	return &Heartbeat{}
}

func (m *Heartbeat) Pb() *directorpb.Heartbeat {
	if m == nil {
		return nil
	}
	pbMessage := &directorpb.Heartbeat{}
	{
	}

	return pbMessage
}

func (*Heartbeat) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*directorpb.Heartbeat]()}
}

type DoFillGap struct {
	Slot *types.Slot
}

func DoFillGapFromPb(pb *directorpb.DoFillGap) *DoFillGap {
	if pb == nil {
		return nil
	}
	return &DoFillGap{
		Slot: types.SlotFromPb(pb.Slot),
	}
}

func (m *DoFillGap) Pb() *directorpb.DoFillGap {
	if m == nil {
		return nil
	}
	pbMessage := &directorpb.DoFillGap{}
	{
		if m.Slot != nil {
			pbMessage.Slot = (m.Slot).Pb()
		}
	}

	return pbMessage
}

func (*DoFillGap) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*directorpb.DoFillGap]()}
}

type Stats struct {
	SlotsWaitingDelivery uint64
	MinAgDurationEst     time.Duration
	MaxOwnBcDurationEst  time.Duration
	ExtBcDurationEst     time.Duration
	MaxExtBcDurationEst  time.Duration
}

func StatsFromPb(pb *directorpb.Stats) *Stats {
	if pb == nil {
		return nil
	}
	return &Stats{
		SlotsWaitingDelivery: pb.SlotsWaitingDelivery,
		MinAgDurationEst:     (time.Duration)(pb.MinAgDurationEst),
		MaxOwnBcDurationEst:  (time.Duration)(pb.MaxOwnBcDurationEst),
		ExtBcDurationEst:     (time.Duration)(pb.ExtBcDurationEst),
		MaxExtBcDurationEst:  (time.Duration)(pb.MaxExtBcDurationEst),
	}
}

func (m *Stats) Pb() *directorpb.Stats {
	if m == nil {
		return nil
	}
	pbMessage := &directorpb.Stats{}
	{
		pbMessage.SlotsWaitingDelivery = m.SlotsWaitingDelivery
		pbMessage.MinAgDurationEst = (int64)(m.MinAgDurationEst)
		pbMessage.MaxOwnBcDurationEst = (int64)(m.MaxOwnBcDurationEst)
		pbMessage.ExtBcDurationEst = (int64)(m.ExtBcDurationEst)
		pbMessage.MaxExtBcDurationEst = (int64)(m.MaxExtBcDurationEst)
	}

	return pbMessage
}

func (*Stats) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*directorpb.Stats]()}
}
