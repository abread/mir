// Code generated by Mir codegen. DO NOT EDIT.

package directorpbtypes

import (
	mirreflect "github.com/filecoin-project/mir/codegen/mirreflect"
	directorpb "github.com/filecoin-project/mir/pkg/pb/aleapb/directorpb"
	types2 "github.com/filecoin-project/mir/pkg/pb/threshcheckpointpb/types"
	types "github.com/filecoin-project/mir/pkg/trantor/types"
	types1 "github.com/filecoin-project/mir/pkg/types"
	reflectutil "github.com/filecoin-project/mir/pkg/util/reflectutil"
)

type Event struct {
	Type Event_Type
}

type Event_Type interface {
	mirreflect.GeneratedType
	isEvent_Type()
	Pb() directorpb.Event_Type
}

type Event_TypeWrapper[T any] interface {
	Event_Type
	Unwrap() *T
}

func Event_TypeFromPb(pb directorpb.Event_Type) Event_Type {
	if pb == nil {
		return nil
	}
	switch pb := pb.(type) {
	case *directorpb.Event_Heartbeat:
		return &Event_Heartbeat{Heartbeat: HeartbeatFromPb(pb.Heartbeat)}
	case *directorpb.Event_NewEpoch:
		return &Event_NewEpoch{NewEpoch: NewEpochFromPb(pb.NewEpoch)}
	case *directorpb.Event_GcEpochs:
		return &Event_GcEpochs{GcEpochs: GCEpochsFromPb(pb.GcEpochs)}
	case *directorpb.Event_HelpNode:
		return &Event_HelpNode{HelpNode: HelpNodeFromPb(pb.HelpNode)}
	}
	return nil
}

type Event_Heartbeat struct {
	Heartbeat *Heartbeat
}

func (*Event_Heartbeat) isEvent_Type() {}

func (w *Event_Heartbeat) Unwrap() *Heartbeat {
	return w.Heartbeat
}

func (w *Event_Heartbeat) Pb() directorpb.Event_Type {
	if w == nil {
		return nil
	}
	if w.Heartbeat == nil {
		return &directorpb.Event_Heartbeat{}
	}
	return &directorpb.Event_Heartbeat{Heartbeat: (w.Heartbeat).Pb()}
}

func (*Event_Heartbeat) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*directorpb.Event_Heartbeat]()}
}

type Event_NewEpoch struct {
	NewEpoch *NewEpoch
}

func (*Event_NewEpoch) isEvent_Type() {}

func (w *Event_NewEpoch) Unwrap() *NewEpoch {
	return w.NewEpoch
}

func (w *Event_NewEpoch) Pb() directorpb.Event_Type {
	if w == nil {
		return nil
	}
	if w.NewEpoch == nil {
		return &directorpb.Event_NewEpoch{}
	}
	return &directorpb.Event_NewEpoch{NewEpoch: (w.NewEpoch).Pb()}
}

func (*Event_NewEpoch) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*directorpb.Event_NewEpoch]()}
}

type Event_GcEpochs struct {
	GcEpochs *GCEpochs
}

func (*Event_GcEpochs) isEvent_Type() {}

func (w *Event_GcEpochs) Unwrap() *GCEpochs {
	return w.GcEpochs
}

func (w *Event_GcEpochs) Pb() directorpb.Event_Type {
	if w == nil {
		return nil
	}
	if w.GcEpochs == nil {
		return &directorpb.Event_GcEpochs{}
	}
	return &directorpb.Event_GcEpochs{GcEpochs: (w.GcEpochs).Pb()}
}

func (*Event_GcEpochs) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*directorpb.Event_GcEpochs]()}
}

type Event_HelpNode struct {
	HelpNode *HelpNode
}

func (*Event_HelpNode) isEvent_Type() {}

func (w *Event_HelpNode) Unwrap() *HelpNode {
	return w.HelpNode
}

func (w *Event_HelpNode) Pb() directorpb.Event_Type {
	if w == nil {
		return nil
	}
	if w.HelpNode == nil {
		return &directorpb.Event_HelpNode{}
	}
	return &directorpb.Event_HelpNode{HelpNode: (w.HelpNode).Pb()}
}

func (*Event_HelpNode) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*directorpb.Event_HelpNode]()}
}

func EventFromPb(pb *directorpb.Event) *Event {
	if pb == nil {
		return nil
	}
	return &Event{
		Type: Event_TypeFromPb(pb.Type),
	}
}

func (m *Event) Pb() *directorpb.Event {
	if m == nil {
		return nil
	}
	pbMessage := &directorpb.Event{}
	{
		if m.Type != nil {
			pbMessage.Type = (m.Type).Pb()
		}
	}

	return pbMessage
}

func (*Event) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*directorpb.Event]()}
}

type Heartbeat struct{}

func HeartbeatFromPb(pb *directorpb.Heartbeat) *Heartbeat {
	if pb == nil {
		return nil
	}
	return &Heartbeat{}
}

func (m *Heartbeat) Pb() *directorpb.Heartbeat {
	if m == nil {
		return nil
	}
	pbMessage := &directorpb.Heartbeat{}
	{
	}

	return pbMessage
}

func (*Heartbeat) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*directorpb.Heartbeat]()}
}

type NewEpoch struct {
	Epoch types.EpochNr
}

func NewEpochFromPb(pb *directorpb.NewEpoch) *NewEpoch {
	if pb == nil {
		return nil
	}
	return &NewEpoch{
		Epoch: (types.EpochNr)(pb.Epoch),
	}
}

func (m *NewEpoch) Pb() *directorpb.NewEpoch {
	if m == nil {
		return nil
	}
	pbMessage := &directorpb.NewEpoch{}
	{
		pbMessage.Epoch = (uint64)(m.Epoch)
	}

	return pbMessage
}

func (*NewEpoch) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*directorpb.NewEpoch]()}
}

type GCEpochs struct {
	MinEpoch types.EpochNr
}

func GCEpochsFromPb(pb *directorpb.GCEpochs) *GCEpochs {
	if pb == nil {
		return nil
	}
	return &GCEpochs{
		MinEpoch: (types.EpochNr)(pb.MinEpoch),
	}
}

func (m *GCEpochs) Pb() *directorpb.GCEpochs {
	if m == nil {
		return nil
	}
	pbMessage := &directorpb.GCEpochs{}
	{
		pbMessage.MinEpoch = (uint64)(m.MinEpoch)
	}

	return pbMessage
}

func (*GCEpochs) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*directorpb.GCEpochs]()}
}

type HelpNode struct {
	NodeId types1.NodeID
}

func HelpNodeFromPb(pb *directorpb.HelpNode) *HelpNode {
	if pb == nil {
		return nil
	}
	return &HelpNode{
		NodeId: (types1.NodeID)(pb.NodeId),
	}
}

func (m *HelpNode) Pb() *directorpb.HelpNode {
	if m == nil {
		return nil
	}
	pbMessage := &directorpb.HelpNode{}
	{
		pbMessage.NodeId = (string)(m.NodeId)
	}

	return pbMessage
}

func (*HelpNode) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*directorpb.HelpNode]()}
}

type Message struct {
	Type Message_Type
}

type Message_Type interface {
	mirreflect.GeneratedType
	isMessage_Type()
	Pb() directorpb.Message_Type
}

type Message_TypeWrapper[T any] interface {
	Message_Type
	Unwrap() *T
}

func Message_TypeFromPb(pb directorpb.Message_Type) Message_Type {
	if pb == nil {
		return nil
	}
	switch pb := pb.(type) {
	case *directorpb.Message_StableCheckpoint:
		return &Message_StableCheckpoint{StableCheckpoint: StableCheckpointFromPb(pb.StableCheckpoint)}
	}
	return nil
}

type Message_StableCheckpoint struct {
	StableCheckpoint *StableCheckpoint
}

func (*Message_StableCheckpoint) isMessage_Type() {}

func (w *Message_StableCheckpoint) Unwrap() *StableCheckpoint {
	return w.StableCheckpoint
}

func (w *Message_StableCheckpoint) Pb() directorpb.Message_Type {
	if w == nil {
		return nil
	}
	if w.StableCheckpoint == nil {
		return &directorpb.Message_StableCheckpoint{}
	}
	return &directorpb.Message_StableCheckpoint{StableCheckpoint: (w.StableCheckpoint).Pb()}
}

func (*Message_StableCheckpoint) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*directorpb.Message_StableCheckpoint]()}
}

func MessageFromPb(pb *directorpb.Message) *Message {
	if pb == nil {
		return nil
	}
	return &Message{
		Type: Message_TypeFromPb(pb.Type),
	}
}

func (m *Message) Pb() *directorpb.Message {
	if m == nil {
		return nil
	}
	pbMessage := &directorpb.Message{}
	{
		if m.Type != nil {
			pbMessage.Type = (m.Type).Pb()
		}
	}

	return pbMessage
}

func (*Message) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*directorpb.Message]()}
}

type StableCheckpoint struct {
	Checkpoint *types2.StableCheckpoint
}

func StableCheckpointFromPb(pb *directorpb.StableCheckpoint) *StableCheckpoint {
	if pb == nil {
		return nil
	}
	return &StableCheckpoint{
		Checkpoint: types2.StableCheckpointFromPb(pb.Checkpoint),
	}
}

func (m *StableCheckpoint) Pb() *directorpb.StableCheckpoint {
	if m == nil {
		return nil
	}
	pbMessage := &directorpb.StableCheckpoint{}
	{
		if m.Checkpoint != nil {
			pbMessage.Checkpoint = (m.Checkpoint).Pb()
		}
	}

	return pbMessage
}

func (*StableCheckpoint) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*directorpb.StableCheckpoint]()}
}
