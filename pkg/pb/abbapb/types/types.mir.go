// Code generated by Mir codegen. DO NOT EDIT.

package abbapbtypes

import (
	"time"

	mirreflect "github.com/filecoin-project/mir/codegen/mirreflect"
	abbatypes "github.com/filecoin-project/mir/pkg/abba/abbatypes"
	abbapb "github.com/filecoin-project/mir/pkg/pb/abbapb"
	tctypes "github.com/filecoin-project/mir/pkg/threshcrypto/tctypes"
	types "github.com/filecoin-project/mir/pkg/types"
	reflectutil "github.com/filecoin-project/mir/pkg/util/reflectutil"
)

type Event struct {
	Type Event_Type
}

type Event_Type interface {
	mirreflect.GeneratedType
	isEvent_Type()
	Pb() abbapb.Event_Type
}

type Event_TypeWrapper[T any] interface {
	Event_Type
	Unwrap() *T
}

func Event_TypeFromPb(pb abbapb.Event_Type) Event_Type {
	if pb == nil {
		return nil
	}
	switch pb := pb.(type) {
	case *abbapb.Event_InputValue:
		return &Event_InputValue{InputValue: InputValueFromPb(pb.InputValue)}
	case *abbapb.Event_Deliver:
		return &Event_Deliver{Deliver: DeliverFromPb(pb.Deliver)}
	case *abbapb.Event_Round:
		return &Event_Round{Round: RoundEventFromPb(pb.Round)}
	case *abbapb.Event_Done:
		return &Event_Done{Done: DoneFromPb(pb.Done)}
	}
	return nil
}

type Event_InputValue struct {
	InputValue *InputValue
}

func (*Event_InputValue) isEvent_Type() {}

func (w *Event_InputValue) Unwrap() *InputValue {
	return w.InputValue
}

func (w *Event_InputValue) Pb() abbapb.Event_Type {
	if w == nil {
		return nil
	}
	if w.InputValue == nil {
		return &abbapb.Event_InputValue{}
	}
	return &abbapb.Event_InputValue{InputValue: (w.InputValue).Pb()}
}

func (*Event_InputValue) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*abbapb.Event_InputValue]()}
}

type Event_Deliver struct {
	Deliver *Deliver
}

func (*Event_Deliver) isEvent_Type() {}

func (w *Event_Deliver) Unwrap() *Deliver {
	return w.Deliver
}

func (w *Event_Deliver) Pb() abbapb.Event_Type {
	if w == nil {
		return nil
	}
	if w.Deliver == nil {
		return &abbapb.Event_Deliver{}
	}
	return &abbapb.Event_Deliver{Deliver: (w.Deliver).Pb()}
}

func (*Event_Deliver) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*abbapb.Event_Deliver]()}
}

type Event_Round struct {
	Round *RoundEvent
}

func (*Event_Round) isEvent_Type() {}

func (w *Event_Round) Unwrap() *RoundEvent {
	return w.Round
}

func (w *Event_Round) Pb() abbapb.Event_Type {
	if w == nil {
		return nil
	}
	if w.Round == nil {
		return &abbapb.Event_Round{}
	}
	return &abbapb.Event_Round{Round: (w.Round).Pb()}
}

func (*Event_Round) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*abbapb.Event_Round]()}
}

type Event_Done struct {
	Done *Done
}

func (*Event_Done) isEvent_Type() {}

func (w *Event_Done) Unwrap() *Done {
	return w.Done
}

func (w *Event_Done) Pb() abbapb.Event_Type {
	if w == nil {
		return nil
	}
	if w.Done == nil {
		return &abbapb.Event_Done{}
	}
	return &abbapb.Event_Done{Done: (w.Done).Pb()}
}

func (*Event_Done) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*abbapb.Event_Done]()}
}

func EventFromPb(pb *abbapb.Event) *Event {
	if pb == nil {
		return nil
	}
	return &Event{
		Type: Event_TypeFromPb(pb.Type),
	}
}

func (m *Event) Pb() *abbapb.Event {
	if m == nil {
		return nil
	}
	pbMessage := &abbapb.Event{}
	{
		if m.Type != nil {
			pbMessage.Type = (m.Type).Pb()
		}
	}

	return pbMessage
}

func (*Event) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*abbapb.Event]()}
}

type InputValue struct {
	Input bool
}

func InputValueFromPb(pb *abbapb.InputValue) *InputValue {
	if pb == nil {
		return nil
	}
	return &InputValue{
		Input: pb.Input,
	}
}

func (m *InputValue) Pb() *abbapb.InputValue {
	if m == nil {
		return nil
	}
	pbMessage := &abbapb.InputValue{}
	{
		pbMessage.Input = m.Input
	}

	return pbMessage
}

func (*InputValue) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*abbapb.InputValue]()}
}

type Deliver struct {
	Result    bool
	SrcModule types.ModuleID
}

func DeliverFromPb(pb *abbapb.Deliver) *Deliver {
	if pb == nil {
		return nil
	}
	return &Deliver{
		Result:    pb.Result,
		SrcModule: (types.ModuleID)(pb.SrcModule),
	}
}

func (m *Deliver) Pb() *abbapb.Deliver {
	if m == nil {
		return nil
	}
	pbMessage := &abbapb.Deliver{}
	{
		pbMessage.Result = m.Result
		pbMessage.SrcModule = (string)(m.SrcModule)
	}

	return pbMessage
}

func (*Deliver) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*abbapb.Deliver]()}
}

type Done struct {
	SrcModule types.ModuleID
}

func DoneFromPb(pb *abbapb.Done) *Done {
	if pb == nil {
		return nil
	}
	return &Done{
		SrcModule: (types.ModuleID)(pb.SrcModule),
	}
}

func (m *Done) Pb() *abbapb.Done {
	if m == nil {
		return nil
	}
	pbMessage := &abbapb.Done{}
	{
		pbMessage.SrcModule = (string)(m.SrcModule)
	}

	return pbMessage
}

func (*Done) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*abbapb.Done]()}
}

type Message struct {
	Type Message_Type
}

type Message_Type interface {
	mirreflect.GeneratedType
	isMessage_Type()
	Pb() abbapb.Message_Type
}

type Message_TypeWrapper[T any] interface {
	Message_Type
	Unwrap() *T
}

func Message_TypeFromPb(pb abbapb.Message_Type) Message_Type {
	if pb == nil {
		return nil
	}
	switch pb := pb.(type) {
	case *abbapb.Message_Finish:
		return &Message_Finish{Finish: FinishMessageFromPb(pb.Finish)}
	case *abbapb.Message_Round:
		return &Message_Round{Round: RoundMessageFromPb(pb.Round)}
	}
	return nil
}

type Message_Finish struct {
	Finish *FinishMessage
}

func (*Message_Finish) isMessage_Type() {}

func (w *Message_Finish) Unwrap() *FinishMessage {
	return w.Finish
}

func (w *Message_Finish) Pb() abbapb.Message_Type {
	if w == nil {
		return nil
	}
	if w.Finish == nil {
		return &abbapb.Message_Finish{}
	}
	return &abbapb.Message_Finish{Finish: (w.Finish).Pb()}
}

func (*Message_Finish) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*abbapb.Message_Finish]()}
}

type Message_Round struct {
	Round *RoundMessage
}

func (*Message_Round) isMessage_Type() {}

func (w *Message_Round) Unwrap() *RoundMessage {
	return w.Round
}

func (w *Message_Round) Pb() abbapb.Message_Type {
	if w == nil {
		return nil
	}
	if w.Round == nil {
		return &abbapb.Message_Round{}
	}
	return &abbapb.Message_Round{Round: (w.Round).Pb()}
}

func (*Message_Round) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*abbapb.Message_Round]()}
}

func MessageFromPb(pb *abbapb.Message) *Message {
	if pb == nil {
		return nil
	}
	return &Message{
		Type: Message_TypeFromPb(pb.Type),
	}
}

func (m *Message) Pb() *abbapb.Message {
	if m == nil {
		return nil
	}
	pbMessage := &abbapb.Message{}
	{
		if m.Type != nil {
			pbMessage.Type = (m.Type).Pb()
		}
	}

	return pbMessage
}

func (*Message) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*abbapb.Message]()}
}

type FinishMessage struct {
	Value bool
}

func FinishMessageFromPb(pb *abbapb.FinishMessage) *FinishMessage {
	if pb == nil {
		return nil
	}
	return &FinishMessage{
		Value: pb.Value,
	}
}

func (m *FinishMessage) Pb() *abbapb.FinishMessage {
	if m == nil {
		return nil
	}
	pbMessage := &abbapb.FinishMessage{}
	{
		pbMessage.Value = m.Value
	}

	return pbMessage
}

func (*FinishMessage) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*abbapb.FinishMessage]()}
}

type RoundEvent struct {
	Type RoundEvent_Type
}

type RoundEvent_Type interface {
	mirreflect.GeneratedType
	isRoundEvent_Type()
	Pb() abbapb.RoundEvent_Type
}

type RoundEvent_TypeWrapper[T any] interface {
	RoundEvent_Type
	Unwrap() *T
}

func RoundEvent_TypeFromPb(pb abbapb.RoundEvent_Type) RoundEvent_Type {
	if pb == nil {
		return nil
	}
	switch pb := pb.(type) {
	case *abbapb.RoundEvent_InputValue:
		return &RoundEvent_InputValue{InputValue: RoundInputValueFromPb(pb.InputValue)}
	case *abbapb.RoundEvent_Deliver:
		return &RoundEvent_Deliver{Deliver: RoundDeliverFromPb(pb.Deliver)}
	case *abbapb.RoundEvent_Finish:
		return &RoundEvent_Finish{Finish: RoundFinishAllFromPb(pb.Finish)}
	}
	return nil
}

type RoundEvent_InputValue struct {
	InputValue *RoundInputValue
}

func (*RoundEvent_InputValue) isRoundEvent_Type() {}

func (w *RoundEvent_InputValue) Unwrap() *RoundInputValue {
	return w.InputValue
}

func (w *RoundEvent_InputValue) Pb() abbapb.RoundEvent_Type {
	if w == nil {
		return nil
	}
	if w.InputValue == nil {
		return &abbapb.RoundEvent_InputValue{}
	}
	return &abbapb.RoundEvent_InputValue{InputValue: (w.InputValue).Pb()}
}

func (*RoundEvent_InputValue) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*abbapb.RoundEvent_InputValue]()}
}

type RoundEvent_Deliver struct {
	Deliver *RoundDeliver
}

func (*RoundEvent_Deliver) isRoundEvent_Type() {}

func (w *RoundEvent_Deliver) Unwrap() *RoundDeliver {
	return w.Deliver
}

func (w *RoundEvent_Deliver) Pb() abbapb.RoundEvent_Type {
	if w == nil {
		return nil
	}
	if w.Deliver == nil {
		return &abbapb.RoundEvent_Deliver{}
	}
	return &abbapb.RoundEvent_Deliver{Deliver: (w.Deliver).Pb()}
}

func (*RoundEvent_Deliver) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*abbapb.RoundEvent_Deliver]()}
}

type RoundEvent_Finish struct {
	Finish *RoundFinishAll
}

func (*RoundEvent_Finish) isRoundEvent_Type() {}

func (w *RoundEvent_Finish) Unwrap() *RoundFinishAll {
	return w.Finish
}

func (w *RoundEvent_Finish) Pb() abbapb.RoundEvent_Type {
	if w == nil {
		return nil
	}
	if w.Finish == nil {
		return &abbapb.RoundEvent_Finish{}
	}
	return &abbapb.RoundEvent_Finish{Finish: (w.Finish).Pb()}
}

func (*RoundEvent_Finish) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*abbapb.RoundEvent_Finish]()}
}

func RoundEventFromPb(pb *abbapb.RoundEvent) *RoundEvent {
	if pb == nil {
		return nil
	}
	return &RoundEvent{
		Type: RoundEvent_TypeFromPb(pb.Type),
	}
}

func (m *RoundEvent) Pb() *abbapb.RoundEvent {
	if m == nil {
		return nil
	}
	pbMessage := &abbapb.RoundEvent{}
	{
		if m.Type != nil {
			pbMessage.Type = (m.Type).Pb()
		}
	}

	return pbMessage
}

func (*RoundEvent) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*abbapb.RoundEvent]()}
}

type RoundInputValue struct {
	Input bool
}

func RoundInputValueFromPb(pb *abbapb.RoundInputValue) *RoundInputValue {
	if pb == nil {
		return nil
	}
	return &RoundInputValue{
		Input: pb.Input,
	}
}

func (m *RoundInputValue) Pb() *abbapb.RoundInputValue {
	if m == nil {
		return nil
	}
	pbMessage := &abbapb.RoundInputValue{}
	{
		pbMessage.Input = m.Input
	}

	return pbMessage
}

func (*RoundInputValue) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*abbapb.RoundInputValue]()}
}

type RoundDeliver struct {
	NextEstimate   bool
	RoundNumber    uint64
	DurationNoCoin time.Duration
}

func RoundDeliverFromPb(pb *abbapb.RoundDeliver) *RoundDeliver {
	if pb == nil {
		return nil
	}
	return &RoundDeliver{
		NextEstimate:   pb.NextEstimate,
		RoundNumber:    pb.RoundNumber,
		DurationNoCoin: (time.Duration)(pb.DurationNoCoin),
	}
}

func (m *RoundDeliver) Pb() *abbapb.RoundDeliver {
	if m == nil {
		return nil
	}
	pbMessage := &abbapb.RoundDeliver{}
	{
		pbMessage.NextEstimate = m.NextEstimate
		pbMessage.RoundNumber = m.RoundNumber
		pbMessage.DurationNoCoin = (int64)(m.DurationNoCoin)
	}

	return pbMessage
}

func (*RoundDeliver) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*abbapb.RoundDeliver]()}
}

type RoundFinishAll struct {
	Decision  bool
	Unanimous bool
}

func RoundFinishAllFromPb(pb *abbapb.RoundFinishAll) *RoundFinishAll {
	if pb == nil {
		return nil
	}
	return &RoundFinishAll{
		Decision:  pb.Decision,
		Unanimous: pb.Unanimous,
	}
}

func (m *RoundFinishAll) Pb() *abbapb.RoundFinishAll {
	if m == nil {
		return nil
	}
	pbMessage := &abbapb.RoundFinishAll{}
	{
		pbMessage.Decision = m.Decision
		pbMessage.Unanimous = m.Unanimous
	}

	return pbMessage
}

func (*RoundFinishAll) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*abbapb.RoundFinishAll]()}
}

type RoundMessage struct {
	Type RoundMessage_Type
}

type RoundMessage_Type interface {
	mirreflect.GeneratedType
	isRoundMessage_Type()
	Pb() abbapb.RoundMessage_Type
}

type RoundMessage_TypeWrapper[T any] interface {
	RoundMessage_Type
	Unwrap() *T
}

func RoundMessage_TypeFromPb(pb abbapb.RoundMessage_Type) RoundMessage_Type {
	if pb == nil {
		return nil
	}
	switch pb := pb.(type) {
	case *abbapb.RoundMessage_Input:
		return &RoundMessage_Input{Input: RoundInputMessageFromPb(pb.Input)}
	case *abbapb.RoundMessage_Init:
		return &RoundMessage_Init{Init: RoundInitMessageFromPb(pb.Init)}
	case *abbapb.RoundMessage_Aux:
		return &RoundMessage_Aux{Aux: RoundAuxMessageFromPb(pb.Aux)}
	case *abbapb.RoundMessage_Conf:
		return &RoundMessage_Conf{Conf: RoundConfMessageFromPb(pb.Conf)}
	case *abbapb.RoundMessage_Coin:
		return &RoundMessage_Coin{Coin: RoundCoinMessageFromPb(pb.Coin)}
	}
	return nil
}

type RoundMessage_Input struct {
	Input *RoundInputMessage
}

func (*RoundMessage_Input) isRoundMessage_Type() {}

func (w *RoundMessage_Input) Unwrap() *RoundInputMessage {
	return w.Input
}

func (w *RoundMessage_Input) Pb() abbapb.RoundMessage_Type {
	if w == nil {
		return nil
	}
	if w.Input == nil {
		return &abbapb.RoundMessage_Input{}
	}
	return &abbapb.RoundMessage_Input{Input: (w.Input).Pb()}
}

func (*RoundMessage_Input) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*abbapb.RoundMessage_Input]()}
}

type RoundMessage_Init struct {
	Init *RoundInitMessage
}

func (*RoundMessage_Init) isRoundMessage_Type() {}

func (w *RoundMessage_Init) Unwrap() *RoundInitMessage {
	return w.Init
}

func (w *RoundMessage_Init) Pb() abbapb.RoundMessage_Type {
	if w == nil {
		return nil
	}
	if w.Init == nil {
		return &abbapb.RoundMessage_Init{}
	}
	return &abbapb.RoundMessage_Init{Init: (w.Init).Pb()}
}

func (*RoundMessage_Init) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*abbapb.RoundMessage_Init]()}
}

type RoundMessage_Aux struct {
	Aux *RoundAuxMessage
}

func (*RoundMessage_Aux) isRoundMessage_Type() {}

func (w *RoundMessage_Aux) Unwrap() *RoundAuxMessage {
	return w.Aux
}

func (w *RoundMessage_Aux) Pb() abbapb.RoundMessage_Type {
	if w == nil {
		return nil
	}
	if w.Aux == nil {
		return &abbapb.RoundMessage_Aux{}
	}
	return &abbapb.RoundMessage_Aux{Aux: (w.Aux).Pb()}
}

func (*RoundMessage_Aux) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*abbapb.RoundMessage_Aux]()}
}

type RoundMessage_Conf struct {
	Conf *RoundConfMessage
}

func (*RoundMessage_Conf) isRoundMessage_Type() {}

func (w *RoundMessage_Conf) Unwrap() *RoundConfMessage {
	return w.Conf
}

func (w *RoundMessage_Conf) Pb() abbapb.RoundMessage_Type {
	if w == nil {
		return nil
	}
	if w.Conf == nil {
		return &abbapb.RoundMessage_Conf{}
	}
	return &abbapb.RoundMessage_Conf{Conf: (w.Conf).Pb()}
}

func (*RoundMessage_Conf) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*abbapb.RoundMessage_Conf]()}
}

type RoundMessage_Coin struct {
	Coin *RoundCoinMessage
}

func (*RoundMessage_Coin) isRoundMessage_Type() {}

func (w *RoundMessage_Coin) Unwrap() *RoundCoinMessage {
	return w.Coin
}

func (w *RoundMessage_Coin) Pb() abbapb.RoundMessage_Type {
	if w == nil {
		return nil
	}
	if w.Coin == nil {
		return &abbapb.RoundMessage_Coin{}
	}
	return &abbapb.RoundMessage_Coin{Coin: (w.Coin).Pb()}
}

func (*RoundMessage_Coin) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*abbapb.RoundMessage_Coin]()}
}

func RoundMessageFromPb(pb *abbapb.RoundMessage) *RoundMessage {
	if pb == nil {
		return nil
	}
	return &RoundMessage{
		Type: RoundMessage_TypeFromPb(pb.Type),
	}
}

func (m *RoundMessage) Pb() *abbapb.RoundMessage {
	if m == nil {
		return nil
	}
	pbMessage := &abbapb.RoundMessage{}
	{
		if m.Type != nil {
			pbMessage.Type = (m.Type).Pb()
		}
	}

	return pbMessage
}

func (*RoundMessage) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*abbapb.RoundMessage]()}
}

type RoundInputMessage struct {
	Estimate bool
}

func RoundInputMessageFromPb(pb *abbapb.RoundInputMessage) *RoundInputMessage {
	if pb == nil {
		return nil
	}
	return &RoundInputMessage{
		Estimate: pb.Estimate,
	}
}

func (m *RoundInputMessage) Pb() *abbapb.RoundInputMessage {
	if m == nil {
		return nil
	}
	pbMessage := &abbapb.RoundInputMessage{}
	{
		pbMessage.Estimate = m.Estimate
	}

	return pbMessage
}

func (*RoundInputMessage) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*abbapb.RoundInputMessage]()}
}

type RoundInitMessage struct {
	Estimate bool
}

func RoundInitMessageFromPb(pb *abbapb.RoundInitMessage) *RoundInitMessage {
	if pb == nil {
		return nil
	}
	return &RoundInitMessage{
		Estimate: pb.Estimate,
	}
}

func (m *RoundInitMessage) Pb() *abbapb.RoundInitMessage {
	if m == nil {
		return nil
	}
	pbMessage := &abbapb.RoundInitMessage{}
	{
		pbMessage.Estimate = m.Estimate
	}

	return pbMessage
}

func (*RoundInitMessage) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*abbapb.RoundInitMessage]()}
}

type RoundAuxMessage struct {
	Value bool
}

func RoundAuxMessageFromPb(pb *abbapb.RoundAuxMessage) *RoundAuxMessage {
	if pb == nil {
		return nil
	}
	return &RoundAuxMessage{
		Value: pb.Value,
	}
}

func (m *RoundAuxMessage) Pb() *abbapb.RoundAuxMessage {
	if m == nil {
		return nil
	}
	pbMessage := &abbapb.RoundAuxMessage{}
	{
		pbMessage.Value = m.Value
	}

	return pbMessage
}

func (*RoundAuxMessage) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*abbapb.RoundAuxMessage]()}
}

type RoundConfMessage struct {
	Values abbatypes.ValueSet
}

func RoundConfMessageFromPb(pb *abbapb.RoundConfMessage) *RoundConfMessage {
	if pb == nil {
		return nil
	}
	return &RoundConfMessage{
		Values: (abbatypes.ValueSet)(pb.Values),
	}
}

func (m *RoundConfMessage) Pb() *abbapb.RoundConfMessage {
	if m == nil {
		return nil
	}
	pbMessage := &abbapb.RoundConfMessage{}
	{
		pbMessage.Values = (uint32)(m.Values)
	}

	return pbMessage
}

func (*RoundConfMessage) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*abbapb.RoundConfMessage]()}
}

type RoundCoinMessage struct {
	CoinShare tctypes.SigShare
}

func RoundCoinMessageFromPb(pb *abbapb.RoundCoinMessage) *RoundCoinMessage {
	if pb == nil {
		return nil
	}
	return &RoundCoinMessage{
		CoinShare: (tctypes.SigShare)(pb.CoinShare),
	}
}

func (m *RoundCoinMessage) Pb() *abbapb.RoundCoinMessage {
	if m == nil {
		return nil
	}
	pbMessage := &abbapb.RoundCoinMessage{}
	{
		pbMessage.CoinShare = ([]uint8)(m.CoinShare)
	}

	return pbMessage
}

func (*RoundCoinMessage) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*abbapb.RoundCoinMessage]()}
}
